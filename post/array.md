## 概念
一种**线性**的数据结构，用来存储**相同类型**的数据。

在内存中，以**连续**的方式存储。

## 实现动态数组类
### 属性
* `capacity` 数组容量，实际上等于`data.length`
* `size` 数组中实际存储的元素个数
* `data[]` 实际存储的数据
### 功能
* 添加元素
    * 分为在开头、结尾、中间插入元素。
    * 在开头和中间插入，需要搬移元素。
    * 最好时间复杂度：在结尾插入，复杂度`O(1)`. 最坏时间复杂度：在开头插入，需要搬移n次元素，复杂度`O(N)`。平均时间复杂度：`(1+2+...+n) / n = O(N)` 
    * 优化技巧：插入时，如果元素没有顺序，数组仅仅作为存放元素的容器而存在，可以不搬移元素，而是将要插入位置的元素挪到最后一位。
* 删除元素
    * 与插入类似，需要搬移元素
    * 优化技巧：如果需要删除多个元素，为了避免多次数据搬移，可以先给需要删除的元素做个标记，再统一删除。Java中的标记-清除算法也用到了这种思想。
* 修改元素
    * 修改给定下标的元素
    * 修改指定的元素
* 查询元素
    * 查询给定下标的元素
    * 查询指定的元素
* 扩容和缩容


## 复杂度分析
### 插入和删除
#### 不需要扩容的情况

* 在数组末尾插入，复杂度`O(1)`
* 在数组开头插入，需要搬移整个数组，复杂度`O(n)`
* 在数组任意位置插入，由于在不同的位置插入时需要花费的时间不同，因此可以分为最好情况，最坏情况，分别为在末尾插入和在开头插入。在每个位置插入的概率相等，因此有个平均情况。概率均是`1/n`。平均时间复杂度：
`O(N) = (1+2+...+n)/n = O(n)`

#### 扩容
##### 如何扩容
与数组本身的大小有关。
##### 复杂度
扩容时，需要进行n次数据搬移，复杂度`O(n)`。

##### 均摊
通过分析，我们可以发现，扩容这个操作出现是有规律的。假设当前数组容量是n，那么从0开始每添加n个元素（也就是做n次插入操作），就要做一次扩容，即进行n次数据搬移操作。可以把n次数据搬移操作，均摊到之前的n次插入操作上，这样均摊下来，**均摊复杂度**为`O(1)`。


#### 复杂度震荡
一种比较特殊的情况。

### 修改和查找
* 给定下标，复杂度`O(1)`。
* 在计算机中，由于数组存储在连续的内存空间，由于CPU的缓存机制的存在，进一步提升了查找的效率。
* 如果是查找给定的元素，则还是需要遍历数组，无法利用数组的*查找指定下标的元素很快*的特性。对于这种情况，我们可以给下标赋予一定的语义，这样查找的时候可以尽量通过下标去查找，发挥数组特性的优势。

## 实现时的注意事项
* Java的泛型不支持基本类型，需要使用它们的包装类。
* 在搬移数组元素时，为了展现出搬移数据的过程，方便分析复杂度，用的是循环赋值的方式。Java自带的容器类`ArrayList`使用的是`System.arraycopy()`方法，效率更高。
* 元素之间的比较，用的是`equals()`方法，使用时需要确保传入的类重写了`equals()`方法,或者实现了`Comparable`接口。

## 参考
[StackOverflow: make-copy-of-an-array](https://stackoverflow.com/questions/5785745/make-copy-of-an-array)